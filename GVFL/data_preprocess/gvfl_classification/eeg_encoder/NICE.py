"""
Different EEG encoders for comparison

SA GA

shallownet, deepnet, eegnet, conformer, tsconv
"""


import os
import argparse
import math
import glob
import random
import itertools
import datetime
import time
import numpy as np

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.nn.init as init
from torch import Tensor
from torch.autograd import Variable

# from torchsummary import summary

from einops import rearrange
from einops.layers.torch import Rearrange
from loss import ClipLoss


class PatchEmbedding(nn.Module):
    def __init__(self, num_channels,emb_size=40):
        # self.patch_size = patch_size
        super().__init__()
        self.tsconv = nn.Sequential(
            nn.Conv2d(1, 40, (1, 25), (1, 1)),
            nn.AvgPool2d((1, 51), (1, 5)),
            nn.BatchNorm2d(40),
            nn.ELU(),
            nn.Conv2d(40, 40, (num_channels, 1), (1, 1)),
            nn.BatchNorm2d(40),
            nn.ELU(),
            nn.Dropout(0.5),
        )
        self.deepnet = nn.Sequential(
            nn.Conv2d(1, 25, (1, 10), (1, 1)),
            nn.Conv2d(25, 25, (num_channels, 1), (1, 1)),
            nn.BatchNorm2d(25),
            nn.ELU(),
            nn.MaxPool2d((1, 2), (1, 2)),
            nn.Dropout(0.5),

            nn.Conv2d(25, 50, (1, 10), (1, 1)),
            nn.BatchNorm2d(50),
            nn.ELU(),
            nn.MaxPool2d((1, 2), (1, 2)),
            nn.Dropout(0.5),

            nn.Conv2d(50, 100, (1, 10), (1, 1)),
            nn.BatchNorm2d(100),
            nn.ELU(),
            nn.MaxPool2d((1, 2), (1, 2)),
            nn.Dropout(0.5),

            nn.Conv2d(100, 200, (1, 10), (1, 1)),
            nn.BatchNorm2d(200),
            nn.ELU(),
            nn.MaxPool2d((1, 2), (1, 2)),
            nn.Dropout(0.5),

        )

        self.eegnet = nn.Sequential(
            nn.Conv2d(1, 8, (1, 64), (1, 1)),
            nn.BatchNorm2d(8),
            nn.Conv2d(8, 16, (num_channels, 1), (1, 1)),
            nn.BatchNorm2d(16),
            nn.ELU(),
            nn.AvgPool2d((1, 2), (1, 2)),
            nn.Dropout(0.5),
            nn.Conv2d(16, 16, (1, 16), (1, 1)),
            nn.BatchNorm2d(16), 
            nn.ELU(),
            # nn.AvgPool2d((1, 2), (1, 2)),
            nn.Dropout2d(0.5)
        )

        self.shallownet = nn.Sequential(
            nn.Conv2d(1, 40, (1, 25), (1, 1)),
            nn.Conv2d(40, 40, (num_channels, 1), (1, 1)),
            nn.BatchNorm2d(40),
            nn.ELU(),
            nn.AvgPool2d((1, 51), (1, 5)),
            nn.Dropout(0.5),
        )

        self.projection = nn.Sequential(
            nn.Conv2d(40, emb_size, (1, 1), stride=(1, 1)),  # 5 is better than 1
            Rearrange('b e (h) (w) -> b (h w) e'),
        )

    def forward(self, x: Tensor) -> Tensor:
        x = self.deepnet(x)
        return x


class MultiHeadAttention(nn.Module):
    def __init__(self, emb_size, num_heads, dropout):
        super().__init__()
        self.emb_size = emb_size
        self.num_heads = num_heads
        self.keys = nn.Linear(emb_size, emb_size)
        self.queries = nn.Linear(emb_size, emb_size)
        self.values = nn.Linear(emb_size, emb_size)
        self.att_drop = nn.Dropout(dropout)
        self.projection = nn.Linear(emb_size, emb_size)

    def forward(self, x: Tensor, mask: Tensor = None) -> Tensor:
        queries = rearrange(self.queries(x), "b n (h d) -> b h n d", h=self.num_heads)
        keys = rearrange(self.keys(x), "b n (h d) -> b h n d", h=self.num_heads)
        values = rearrange(self.values(x), "b n (h d) -> b h n d", h=self.num_heads)
        energy = torch.einsum('bhqd, bhkd -> bhqk', queries, keys)  # batch, num_heads, query_len, key_len
        if mask is not None:
            fill_value = torch.finfo(torch.float32).min
            energy.mask_fill(~mask, fill_value)

        scaling = self.emb_size ** (1 / 2)
        att = F.softmax(energy / scaling, dim=-1)
        att = self.att_drop(att)
        out = torch.einsum('bhal, bhlv -> bhav ', att, values)
        out = rearrange(out, "b h n d -> b n (h d)")
        out = self.projection(out)
        return out


class ResidualAdd(nn.Module):
    def __init__(self, fn):
        super().__init__()
        self.fn = fn

    def forward(self, x, **kwargs):
        res = x
        x = self.fn(x, **kwargs)
        x += res
        return x


class FeedForwardBlock(nn.Sequential):
    def __init__(self, emb_size, expansion, drop_p):
        super().__init__(
            nn.Linear(emb_size, expansion * emb_size),
            nn.GELU(),
            nn.Dropout(drop_p),
            nn.Linear(expansion * emb_size, emb_size),
        )


class GELU(nn.Module):
    def forward(self, input: Tensor) -> Tensor:
        return input*0.5*(1.0+torch.erf(input/math.sqrt(2.0)))


class TransformerEncoderBlock(nn.Sequential):
    def __init__(self,
                 emb_size,
                 num_heads=10,
                 drop_p=0.5,
                 forward_expansion=4,
                 forward_drop_p=0.5):
        super().__init__(
            ResidualAdd(nn.Sequential(
                nn.LayerNorm(emb_size),
                MultiHeadAttention(emb_size, num_heads, drop_p),
                nn.Dropout(drop_p)
            )),
            ResidualAdd(nn.Sequential(
                nn.LayerNorm(emb_size),
                FeedForwardBlock(
                    emb_size, expansion=forward_expansion, drop_p=forward_drop_p),
                nn.Dropout(drop_p)
            )
            ))


class TransformerEncoder(nn.Sequential):
    def __init__(self, depth=6, emb_size=512):
        super().__init__(*[TransformerEncoderBlock(emb_size) for _ in range(depth)])


class FlattenHead(nn.Sequential):
    def __init__(self, emb_size, n_classes):
        super().__init__()

    def forward(self, x):
        x = x.contiguous().view(x.size(0), -1)
        return x


class ClassificationHead(nn.Sequential):
    def __init__(self):
        super().__init__()
        self.fc = nn.Sequential(
            nn.Linear(256, 40),
        )

    def forward(self, x):
        cls_out = self.fc(x) 
        return x, cls_out   
    

class channel_attention(nn.Module):
    def __init__(self, num_channels,sequence_num=512, inter=30):
        super(channel_attention, self).__init__()
        self.sequence_num = sequence_num
        self.inter = inter
        self.extract_sequence = int(self.sequence_num / self.inter)  # You could choose to do that for less computation

        self.query = nn.Sequential(
            nn.Linear(num_channels, num_channels),
            nn.LayerNorm(num_channels),  # also may introduce improvement to a certain extent
            nn.Dropout(0.3)
        )
        self.key = nn.Sequential(
            nn.Linear(num_channels, num_channels),
            # nn.LeakyReLU(),
            nn.LayerNorm(num_channels),
            nn.Dropout(0.3)
        )
        # self.value = self.key
        self.projection = nn.Sequential(
            nn.Linear(num_channels, num_channels),
            # nn.LeakyReLU(),
            nn.LayerNorm(num_channels),
            nn.Dropout(0.3),
        )
        self.drop_out = nn.Dropout(0)
        self.pooling = nn.AvgPool2d(kernel_size=(1, self.inter), stride=(1, self.inter))

        for m in self.modules():
            if isinstance(m, nn.Linear):
                nn.init.xavier_normal_(m.weight)
                if m.bias is not None:
                    nn.init.constant_(m.bias, 0.0)

    def forward(self, x):
        temp = rearrange(x, 'b o c s->b o s c')
        temp_query = rearrange(self.query(temp), 'b o s c -> b o c s')
        temp_key = rearrange(self.key(temp), 'b o s c -> b o c s')

        channel_query = temp_query
        channel_key = temp_key

        scaling = self.extract_sequence ** (1 / 2)

        channel_atten = torch.einsum('b o c s, b o m s -> b o c m', channel_query, channel_key) / scaling

        channel_atten_score = F.softmax(channel_atten, dim=-1)
        channel_atten_score = self.drop_out(channel_atten_score)

        out = torch.einsum('b o c s, b o c m -> b o c s', x, channel_atten_score)
        '''
        projections after or before multiplying with attention score are almost the same.
        '''
        out = rearrange(out, 'b o c s -> b o s c')
        out = self.projection(out)
        out = rearrange(out, 'b o s c -> b o c s')
        return out


from torch_geometric.nn import GATConv
class EEG_GAT(nn.Module):
    def __init__(self, num_channels,in_channels=512, out_channels=512):
        super(EEG_GAT, self).__init__()
        self.in_channels = in_channels
        self.out_channels = out_channels
        self.conv1 = GATConv(in_channels=in_channels, out_channels=out_channels, heads=1)
        self.num_channels = num_channels
        # Create a list of tuples representing all possible edges between channels
        self.edge_index_list = torch.Tensor([(i, j) for i in range(self.num_channels) for j in range(self.num_channels) if i != j]).cuda()
        # Convert the list of tuples to a tensor
        self.edge_index = torch.tensor(self.edge_index_list, dtype=torch.long).t().contiguous().cuda()

    def forward(self, x):
        x = x.permute(0,2,1).unsqueeze(1)
        batch_size, _, num_channels, num_features = x.size()
        # Reshape x to (batch_size*num_channels, num_features) to pass through GATConv
        x = x.reshape(batch_size*num_channels, num_features)
        x = self.conv1(x, self.edge_index)
        x = x.view(batch_size, num_channels, -1)
        x = x.unsqueeze(1)
        return x


class Enc_eeg(nn.Sequential):
    def __init__(self, num_channels,emb_size=40, depth=3, n_classes=40, **kwargs):
        super().__init__(
            PatchEmbedding(num_channels,emb_size),
            # TransformerEncoder(depth, emb_size),  # for Transformer
            FlattenHead(emb_size, n_classes)
        )

             
class Proj_eeg(nn.Sequential):
    def __init__(self, embedding_dim=1440, proj_dim=1024, drop_proj=0.5):
        super().__init__(
            nn.Linear(embedding_dim, proj_dim),
            ResidualAdd(nn.Sequential(
                nn.GELU(),
                nn.Linear(proj_dim, proj_dim),
                nn.Dropout(drop_proj),
            )),
            nn.LayerNorm(proj_dim),
        )


class Proj_img(nn.Sequential):
    def __init__(self, embedding_dim=768, proj_dim=768, drop_proj=0.3):
        super().__init__(
            nn.Linear(embedding_dim, proj_dim),
            ResidualAdd(nn.Sequential(
                nn.GELU(),
                nn.Linear(proj_dim, proj_dim),
                nn.Dropout(drop_proj),
            )),
            nn.LayerNorm(proj_dim),
        )
    def forward(self, x):

        return x
class GA_NICE(nn.Sequential):
    def __init__(self, strategy,num_channels):
        super(GA_NICE,self).__init__()
        self.graph = EEG_GAT(num_channels=num_channels)
        self.eeg_encoder = Enc_eeg(num_channels=num_channels)
        self.proj = Proj_eeg(embedding_dim=4600)
        self.strategy = strategy
        self.classifier1 = nn.Linear(1024, 40)
        self.logit_scale = nn.Parameter(torch.ones([]) * np.log(1 / 0.07))
        self.loss_func = ClipLoss()
    def forward(self, x: Tensor) -> Tensor:
        x = self.graph(x)
        x = self.eeg_encoder(x)
        eeg_embedding = self.proj(x)
        if self.strategy == 'retrieval' or self.strategy == 'pretraining':
            return eeg_embedding
        elif self.strategy == 'classify':
            class_logits = self.classifier1(eeg_embedding)
            return class_logits
        elif self.strategy == 'R+C':
            class_logits = self.classifier1(eeg_embedding)
            return eeg_embedding, class_logits
        else:
            print('Unknown strategy')
class SA_NICE(nn.Sequential):
    def __init__(self, strategy,num_channels):
        super(SA_NICE,self).__init__()
        self.att = channel_attention(num_channels=num_channels)
        self.eeg_encoder = Enc_eeg(num_channels=num_channels)
        self.proj = Proj_eeg(embedding_dim=4600)
        self.strategy = strategy
        self.classifier1 = nn.Linear(1024, 40)
        self.logit_scale = nn.Parameter(torch.ones([]) * np.log(1 / 0.07))
        self.loss_func = ClipLoss()
    def forward(self, x: Tensor) -> Tensor:
        x = x.permute(0,2,1).unsqueeze(1)
        x = self.att(x)
        x = self.eeg_encoder(x)
        eeg_embedding = self.proj(x)
        if self.strategy == 'retrieval' or self.strategy == 'pretraining':
            return eeg_embedding
        elif self.strategy == 'classify':
            class_logits = self.classifier1(eeg_embedding)
            return class_logits
        elif self.strategy == 'R+C':
            class_logits = self.classifier1(eeg_embedding)
            return eeg_embedding, class_logits
        else:
            print('Unknown strategy')
class Deepnet_NICE(nn.Sequential):
    def __init__(self, strategy,num_channels):
        super(Deepnet_NICE,self).__init__()

        self.eeg_encoder = Enc_eeg(num_channels=num_channels)
        self.proj = Proj_eeg(embedding_dim= 4600)
        self.strategy = strategy
        self.classifier1 = nn.Linear(1024, 40)
        self.logit_scale = nn.Parameter(torch.ones([]) * np.log(1 / 0.07))
        self.loss_func = ClipLoss()
    def forward(self, x: Tensor) -> Tensor:
        x = x.permute(0,2,1).unsqueeze(1)
        x = self.eeg_encoder(x)

        eeg_embedding = self.proj(x)
        if self.strategy == 'pretraining':
            return eeg_embedding
        elif self.strategy == 'classify':
            class_logits = self.classifier1(eeg_embedding)
            return class_logits
        elif self.strategy == 'R+C':
            class_logits = self.classifier1(eeg_embedding)
            return eeg_embedding, class_logits
        else:
            print('Unknown strategy')
class Shallownet_NICE(nn.Sequential):
    def __init__(self, strategy,num_channels):
        super(Shallownet_NICE,self).__init__()
        self.shallownet = nn.Sequential(
            nn.Conv2d(1, 40, (1, 25), (1, 1)),
            nn.Conv2d(40, 40, (num_channels, 1), (1, 1)),
            nn.BatchNorm2d(40),
            nn.ELU(),
            nn.AvgPool2d((1, 51), (1, 5)),
            nn.Dropout(0.5),
        )

        self.proj = Proj_eeg(embedding_dim=3520)
        self.strategy = strategy
        self.classifier1 = nn.Linear(1024, 40)
        self.logit_scale = nn.Parameter(torch.ones([]) * np.log(1 / 0.07))
        self.loss_func = ClipLoss()
    def forward(self, x: Tensor) -> Tensor:
        x = x.permute(0,2,1).unsqueeze(1)
        x = self.shallownet(x)
        x = x.contiguous().view(x.size(0), -1)

        eeg_embedding = self.proj(x)
        if self.strategy == 'pretraining':
            return eeg_embedding
        elif self.strategy == 'classify':
            class_logits = self.classifier1(eeg_embedding)
            return class_logits
        elif self.strategy == 'R+C':
            class_logits = self.classifier1(eeg_embedding)
            return eeg_embedding, class_logits
        else:
            print('Unknown strategy')
